// Copyright (C) 2014 - Andrea Tagliasacchi
#include "check_error_gl.h"

#pragma once
#include "GL/glew.h" ///< must be included before GLFW
#include "GL/glfw.h"
#include "shader_helpers.h"

/// Convenience constants
static const int ONE = 1;
static const bool DONT_NORMALIZE = false;
static const bool DONT_TRANSPOSE = false;
static const int ZERO_STRIDE = 0;
static const void* ZERO_BUFFER_OFFSET = 0;

namespace opengp{

static int _width = 640;
static int _height = 480;
static void (*_display)(void) = NULL;

void glfwInitWindowSize(int width, int height){
    _width = width;
    _height = height;
}

int glfwCreateWindow(const char* title){
    // GLFW Initialization
    if( !glfwInit() ){
        fprintf( stderr, "Failed to initialize GLFW\n" );
        return EXIT_FAILURE;
    }    
    
    /// Hint GLFW that we would like an OpenGL 3 context (at least)
    glfwOpenWindowHint(GLFW_OPENGL_VERSION_MAJOR, 3);
    glfwOpenWindowHint(GLFW_OPENGL_VERSION_MINOR, 2);
    glfwOpenWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    
    /// Hint for multisampling
    glfwOpenWindowHint(GLFW_FSAA_SAMPLES, 4);
    
    /// Attempt to open the window: fails if required version unavailable
    /// @note Intel GPUs do not support OpenGL 3.0
    if( !glfwOpenWindow(_width, _height, 0,0,0,0, 32,0, GLFW_WINDOW ) ){
        fprintf( stderr, "Failed to open OpenGL 3 GLFW window.\n" );
        glfwTerminate();
        return EXIT_FAILURE;
    }

    /// Outputs the OpenGL version
    int major, minor, revision;
    glfwGetGLVersion(&major, &minor,&revision);
    std::cout << "Opened GLFW OpenGL " << major << "." << minor << "." << revision << std::endl;
    
    // GLEW Initialization (must have a context)
    glewExperimental = true;
    if( glewInit() != GLEW_NO_ERROR ){
        
        fprintf( stderr, "Failed to initialize GLEW\n"); 
        return EXIT_FAILURE;
    }
    
    ///--- get rid of GL_INVALID_ENUM error generated by GLFW
    GLenum error;
    while ((error = glGetError()) != GL_NO_ERROR) {
        if(error!=GL_INVALID_ENUM){
            fprintf(stderr, "!!!ERROR: glfwCreateWindow failed");
            exit(0);
        }
    }
    check_error_gl();          
    
    /// Set window title
    glfwSetWindowTitle(title);
    
    return EXIT_SUCCESS;
}


/// @see glutDisplayFunc
void glfwDisplayFunc(void (*display)(void)){    
    _display = display;
}

/// @see glutMainLoop
void glfwMainLoop(){
    assert(_display!=NULL);
    
    /// Render loop & keyboard input
    while(glfwGetKey(GLFW_KEY_ESC)!=GLFW_PRESS && glfwGetWindowParam(GLFW_OPENED)){
        _display();
        glfwSwapBuffers();
    }
    
    /// Close OpenGL window and terminate GLFW
    glfwTerminate();
}

/// @todo document texture loading 
GLuint load_texture_targa(const std::string& path){
    // Create one OpenGL texture
    GLuint textureID;
    glGenTextures(ONE, &textureID);

    // "Bind" the newly created texture : all future texture functions will modify this texture
    glBindTexture(GL_TEXTURE_2D, textureID);

    // Read the file, call glTexImage2D with the right parameters
    glfwLoadTexture2D(path.c_str(), 0);

    // Nice trilinear filtering.
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
    glGenerateMipmap(GL_TEXTURE_2D);

    // Return the ID of the texture we just created
    return textureID;
}

} // opengp::
